<template>
  <div class="max-w-5xl mx-auto px-4 pt-8">
    
    <!-- Общий скелетон для всей страницы при загрузке -->
    <template v-if="pending">
      <div class="space-y-6">
        <!-- Заголовок -->
        <div>
          <USkeleton class="h-7 w-2/3 mb-2" />
          <USkeleton class="h-4 w-1/3 mb-4" />
        </div>
        
        <!-- Коды МКБ -->
        <div class="mb-4">
          <div class="flex flex-wrap gap-2 items-center mb-2">
            <div class="text-sm text-slate-500 dark:text-slate-400">Коды МКБ:</div>
            <USkeleton class="h-6 w-16 rounded" />
            <USkeleton class="h-6 w-14 rounded" />
            <USkeleton class="h-6 w-20 rounded" />
          </div>
        </div>
        
        <!-- Основной контент -->
        <div class="space-y-4">
          <USkeleton class="h-4 w-full" />
          <USkeleton class="h-4 w-5/6" />
          <USkeleton class="h-4 w-4/5" />
          <USkeleton class="h-4 w-3/4" />
          <USkeleton class="h-4 w-5/6" />
          <USkeleton class="h-4 w-2/3" />
        </div>
        
        <!-- Локальные статусы -->
        <div class="border border-slate-200 dark:border-slate-700 rounded-lg">
          <div class="p-4 border-b border-slate-100 dark:border-slate-700">
            <USkeleton class="h-4 w-32" />
          </div>
          <div class="p-4">
            <div class="space-y-3">
              <USkeleton class="h-4 w-3/4" />
              <USkeleton class="h-4 w-1/2" />
              <USkeleton class="h-4 w-2/3" />
            </div>
          </div>
        </div>
      </div>
    </template>
  </div>

  <!-- Основной контент -->
  <div v-if="!pending" class="max-w-5xl mx-auto px-4">
    <!-- Заголовок -->
    <template v-if="!algo">
      <USkeleton class="h-7 w-2/3 mb-2" />
      <USkeleton class="h-4 w-1/3 mb-4" />
    </template>
    <template v-else>
      <h1 class="text-2xl font-bold mb-2 text-slate-900 dark:text-white">{{ algo?.title }}</h1>
      <div class="text-sm text-slate-500 mb-4">{{ getSectionDisplayName(algo?.section) }} • {{ algo?.category?.name }}</div>
    </template>
    
    <!-- Основные коды МКБ -->
    <ClientOnly>
      <div v-if="(algo?.mkbCodes || []).length > 0" class="mb-4">
        <div class="flex flex-wrap gap-2 items-center mb-2">
          <div class="text-sm text-slate-500 dark:text-slate-400">Коды МКБ:</div>
          <button 
            v-for="chip in displayMkbChips" 
            :key="chip" 
            @click="openCodifierPage(chip)"
            class="bg-slate-100 dark:bg-slate-700 text-slate-700 dark:text-slate-200 text-xs px-2 py-1 rounded font-mono hover:bg-slate-200 dark:hover:bg-slate-600 transition-colors cursor-pointer whitespace-nowrap"
          >
            {{ chip }}
          </button>
        </div>
      </div>
      <div v-else-if="!algo" class="mb-4">
        <div class="flex flex-wrap gap-2 items-center mb-2">
          <div class="text-sm text-slate-500 dark:text-slate-400">Коды МКБ:</div>
          <USkeleton class="h-6 w-16 rounded" />
          <USkeleton class="h-6 w-14 rounded" />
          <USkeleton class="h-6 w-20 rounded" />
        </div>
      </div>

      <!-- Исключения -->
      <div v-if="(algo?.mkbExclusions || []).length > 0" class="mb-4">
        <div class="text-sm text-slate-500 dark:text-slate-400 mb-2">Исключения:</div>
        <div class="flex flex-wrap gap-2 items-center">
          <button 
            v-for="code in (algo?.mkbExclusions || [])" 
            :key="`exclusion-${code}`" 
            @click="openCodifierPage(code)"
            class="bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 text-xs px-2 py-1 rounded font-mono hover:bg-red-200 dark:hover:bg-red-900/50 transition-colors cursor-pointer"
          >
            {{ code }}
          </button>
        </div>
      </div>
      <div v-else-if="!algo" class="mb-4">
        <div class="text-sm text-slate-500 dark:text-slate-400 mb-2">Исключения:</div>
        <div class="flex flex-wrap gap-2 items-center">
          <USkeleton class="h-6 w-12 rounded" />
          <USkeleton class="h-6 w-16 rounded" />
        </div>
      </div>
      
      <template #fallback>
        <!-- Fallback для SSR -->
        <div v-if="(algo?.mkbCodes || []).length > 0" class="mb-4">
          <div class="flex flex-wrap gap-2 items-center mb-2">
            <div class="text-sm text-slate-500 dark:text-slate-400">Коды МКБ:</div>
            <span 
              v-for="code in displayMkbChips" 
              :key="code" 
              class="bg-slate-100 dark:bg-slate-700 text-slate-700 dark:text-slate-200 text-xs px-2 py-1 rounded font-mono"
            >
              {{ code }}
            </span>
          </div>
        </div>
        <div v-if="(algo?.mkbExclusions || []).length > 0" class="mb-4">
          <div class="text-sm text-slate-500 dark:text-slate-400 mb-2">Исключения:</div>
          <div class="flex flex-wrap gap-2 items-center">
            <span 
              v-for="code in (algo?.mkbExclusions || [])" 
              :key="`exclusion-${code}`" 
              class="bg-red-100 dark:bg-red-900/30 text-red-700 dark:text-red-300 text-xs px-2 py-1 rounded font-mono"
            >
              {{ code }}
            </span>
          </div>
        </div>
      </template>
    </ClientOnly>
  </div>
  <div class="max-w-5xl mx-auto px-2 md:px-4 pb-8">
    <template v-if="!algo">
      <div class="space-y-4">
        <USkeleton class="h-4 w-full" />
        <USkeleton class="h-4 w-5/6" />
        <USkeleton class="h-4 w-4/5" />
        <USkeleton class="h-4 w-3/4" />
        <USkeleton class="h-4 w-5/6" />
        <USkeleton class="h-4 w-2/3" />
        <USkeleton class="h-4 w-4/5" />
        <USkeleton class="h-4 w-3/4" />
      </div>
    </template>
    <template v-else>
      <div class="prose dark:prose-invert max-w-none w-full" ref="contentRef" v-html="rendered"></div>
    </template>
  </div>

  <!-- Модалка диагноза для десктопа -->
  <UModal 
    v-if="!isMobileDevice"
    v-model:open="diagModalOpen" 
    :title="selectedDiagnosis?.name || ''" 
    description="Информация о заболевании" 
    :ui="{ 
      overlay: 'bg-slate-700/50',
      wrapper: 'sm:max-w-lg',
      content: 'sm:rounded-md rounded-t-md max-h-[80vh] sm:max-h-[85vh]',
      body: 'p-4 sm:p-6 overflow-y-auto custom-scroll',
      close: 'cursor-pointer'
    }"
    modal
    overlay
    transition
  >
    <template #body>
      <div v-if="selectedDiagnosis" class="space-y-4">
        <div class="grid grid-cols-2 gap-4">
          <div>
            <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Код МКБ-10</label>
            <p class="text-lg font-mono font-semibold text-slate-900 dark:text-white">{{ selectedDiagnosis.mkbCode }}</p>
          </div>
          <div>
            <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Код станции</label>
            <p class="text-lg font-mono font-semibold text-slate-900 dark:text-white">{{ selectedDiagnosis.stationCode }}</p>
          </div>
        </div>
        <div>
          <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Нозологическая форма</label>
          <p class="text-lg font-semibold text-slate-900 dark:text-white">{{ selectedDiagnosis.name }}</p>
        </div>
        <div v-if="selectedDiagnosis.note">
          <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Примечание</label>
          <p class="text-slate-600 dark:text-slate-300">{{ selectedDiagnosis.note }}</p>
        </div>
      </div>
      <div v-else class="text-sm text-slate-500">Не удалось загрузить данные диагноза</div>
    </template>
  </UModal>

  <!-- BottomSheet для мобильных устройств -->
  <BottomSheet 
    v-if="isMobileDevice"
    v-model="diagModalOpen"
    :title="selectedDiagnosis?.name || ''"
    :subtitle="selectedDiagnosis?.category?.name || ''"
    @close="diagModalOpen = false"
  >
    <div v-if="selectedDiagnosis" class="space-y-4 px-4 py-2">
      <div class="grid grid-cols-2 gap-4">
        <div>
          <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Код МКБ-10</label>
          <p class="text-lg font-mono font-semibold text-slate-900 dark:text-white">{{ selectedDiagnosis.mkbCode }}</p>
        </div>
        <div>
          <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Код станции</label>
          <p class="text-lg font-mono font-semibold text-slate-900 dark:text-white">{{ selectedDiagnosis.stationCode }}</p>
        </div>
      </div>
      <div>
        <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Нозологическая форма</label>
        <p class="text-lg font-semibold text-slate-900 dark:text-white">{{ selectedDiagnosis.name }}</p>
      </div>
      <div v-if="selectedDiagnosis.note">
        <label class="text-sm font-medium text-slate-700 dark:text-slate-300">Примечание</label>
        <p class="text-slate-600 dark:text-slate-300">{{ selectedDiagnosis.note }}</p>
      </div>
      
      <!-- Кнопки действий -->
      <div class="mt-6 pt-4 border-t border-slate-200 dark:border-slate-600">
        <UButton
          :icon="isBookmarked ? 'i-heroicons-bookmark-solid' : 'i-heroicons-bookmark'"
          :class="isBookmarked
            ? 'text-amber-600 dark:text-amber-400'
            : 'text-slate-600 dark:text-slate-300'"
          variant="outline"
          color="neutral"
          @click="toggleBookmark"
          :disabled="!selectedDiagnosis"
          size="lg"
          :title="isBookmarked ? 'В избранном' : 'В закладки'"
          class="w-full justify-center"
        >
          {{ isBookmarked ? 'В избранном' : 'В закладки' }}
        </UButton>
      </div>
    </div>
    <div v-else class="text-sm text-slate-500 px-4 py-2">Не удалось загрузить данные диагноза</div>
  </BottomSheet>

  <!-- Блок локального статуса -->
  <ClientOnly>
    <div v-if="localStatuses.length > 0" class="max-w-5xl mx-auto md:px-4">
      <div class="bg-white dark:bg-slate-800 rounded-lg">
        <div class="p-4 border-b border-slate-100 dark:border-slate-700">
          <p class="text-sm text-slate-600 dark:text-slate-300">Локальный статус</p>
        </div>
        
        <!-- Найденные локальные статусы -->
        <div class="space-y-0">
          <div v-for="(status, index) in localStatuses" :key="status._id" 
               class="p-4 border-b border-slate-100 dark:border-slate-700"
               :class="{ 'border-b-0': index === localStatuses.length - 1 }">
            
            <!-- Отображение полей локального статуса -->
            <div class="space-y-3 text-sm">
              <div v-if="status.complaints" class="text-slate-600 dark:text-slate-300">
                <span class="font-medium text-slate-700 dark:text-slate-200">Жалобы:</span>
                <p class="mt-1 leading-relaxed">{{ status.complaints }}</p>
              </div>
              
              <div v-if="status.anamnesis" class="text-slate-600 dark:text-slate-300">
                <span class="font-medium text-slate-700 dark:text-slate-200">Анамнез:</span>
                <p class="mt-1 leading-relaxed">{{ status.anamnesis }}</p>
              </div>
              
              <div v-if="status.localis" class="text-slate-600 dark:text-slate-300">
                <span class="font-medium text-slate-700 dark:text-slate-200">Status Localis:</span>
                <p class="mt-1 leading-relaxed">{{ status.localis }}</p>
              </div>
              
              <div v-if="status.description" class="text-slate-600 dark:text-slate-300">
                <span class="font-medium text-slate-700 dark:text-slate-200">Описание:</span>
                <p class="mt-1 leading-relaxed">{{ status.description }}</p>
              </div>
              
              <div v-if="status.note" class="text-slate-600 dark:text-slate-300">
                <span class="font-medium text-slate-700 dark:text-slate-200">Примечание:</span>
                <p class="mt-1 leading-relaxed">{{ status.note }}</p>
              </div>
            </div>
          </div>
        </div>
        
        <!-- Футер с ссылкой на локальный статус -->
        <div class="p-4 border-t border-slate-100 dark:border-slate-700 dark:bg-slate-800">
          <div class="flex items-center justify-between">
            <div class="text-sm text-slate-600 dark:text-slate-300">
              Найдено локальных статусов: {{ localStatuses.length }}
            </div>
            <button 
              @click="openLocalStatusModal"
              class="inline-flex items-center px-3 py-2 text-sm font-medium text-blue-600 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 transition-colors cursor-pointer border border-blue-200 dark:border-blue-700 rounded-md hover:bg-blue-50 dark:hover:bg-blue-900/20"
            >
              <UIcon name="i-heroicons-eye" class="w-4 h-4 mr-2" />
              {{ localStatuses.length === 1 ? 'Открыть' : 'Перейти к категории' }}
            </button>
          </div>
        </div>
      </div>
    </div>
    
    <template #fallback>
      <!-- Fallback для SSR - показываем только заголовок -->
      <div class="max-w-5xl mx-auto px-2 md:px-4 pb-8 mt-8">
        <div class="bg-white dark:bg-slate-800 rounded-lg">
          <div class="p-4 border-b border-slate-100 dark:border-slate-700">
            <p class="text-sm text-slate-600 dark:text-slate-300">Локальный статус</p>
          </div>
          <div class="p-4">
            <div class="space-y-3">
              <USkeleton class="h-4 w-3/4" />
              <USkeleton class="h-4 w-1/2" />
              <USkeleton class="h-4 w-2/3" />
            </div>
          </div>
        </div>
      </div>
    </template>
  </ClientOnly>

  <!-- Модалка препаратов -->
  <SDrugsModal v-model:open="drugsOpen" :query-name="drugsQuery" />

</template>

<style scoped>
/* Обеспечиваем что шапка остается на месте */
thead th {
  position: sticky;
  top: 0;
  z-index: 20;
  background-color: inherit;
}

/* Позиционирование шапки для индикаторов точек */
thead {
  position: relative;
}

/* Обрезка текста в шапке таблицы на мобильной версии */
@media (max-width: 767px) {
  thead th {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
  }
}

/* Стили для индикаторов точек в контейнере таблицы */
[data-mobile-dots-container] {
  background: rgba(255, 255, 255, 0.9);
  backdrop-filter: blur(4px);
  border-radius: 8px;
  padding: 4px 6px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  border: 1px solid rgba(148, 163, 184, 0.2);
}

[data-mobile-dots-container] span {
  transition: background-color 200ms ease-in-out;
}

/* Темная тема для индикаторов */
.dark [data-mobile-dots-container] {
  background: rgba(30, 41, 59, 0.9);
  border-color: rgba(148, 163, 184, 0.3);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Стили для ссылок старого формата внутри контента алгоритма */
:deep(a.algocclink) {
  color: #2563eb !important; /* tailwind blue-600 */
  background-color: #e0f2fe !important; /* tailwind blue-50 */
  padding: .1rem .2rem !important;
  border-radius: .2rem !important;
  text-decoration: none !important;
  display: inline-block !important;
}
:deep(a.algocclink:hover) {
  color: #1d4ed8 !important; /* tailwind blue-700 */
  background-color: #bfdbfe !important; /* tailwind blue-100 */
  text-decoration: none !important;
}

/* Дополнительные стили для надежного закругления углов */
:deep(a.algocclink) {
  border-top-left-radius: .2rem !important;
  border-top-right-radius: .2rem !important;
  border-bottom-left-radius: .2rem !important;
  border-bottom-right-radius: .2rem !important;
  border-radius: .2rem !important;
}

/* Перенос слов в таблицах */
:deep(table td) {
  word-break: break-word;
  overflow-wrap: anywhere;
  line-height: 1.5;
  text-align: left;
  white-space: normal;
  hyphens: auto;
  -webkit-hyphens: auto;
  -ms-hyphens: auto;
  -moz-hyphens: auto;
}
</style>

<script setup lang="ts">
definePageMeta({
  middleware: 'auth'
})

import { marked } from 'marked'
import { nextTick, onMounted, onBeforeUnmount, watch, ref, computed } from 'vue'
const route = useRoute()
const id = route.params.id as string

// Определение мобильного устройства
const isMobileDevice = ref(false)

// Переменные для поиска препаратов
const drugsOpen = ref(false)
const drugsQuery = ref<string>('')

// Переменные для защиты от повторных кликов
const lastClickTime = ref(0)
const lastClickDrugId = ref('')
const isProcessingClick = ref(false)

// Переменная для кэширования списка препаратов
const drugsList = ref<string[]>([])
// Карта препаратов с ID для быстрого поиска
const drugsMap = ref<Map<string, { id: string; name: string; variants: string[] }>>(new Map())

// Константы для localStorage
const DRUGS_CACHE_KEY = 'smp-help-drugs-cache'
const DRUGS_CACHE_VERSION = '1.0'
const DRUGS_CACHE_EXPIRY = 24 * 60 * 60 * 1000 // 24 часа в миллисекундах

// Функции для работы с кэшем препаратов
function saveDrugsToCache(drugsList: string[], drugsMap: Map<string, { id: string; name: string; variants: string[] }>) {
  if (!process.client) return
  
  try {
    const cacheData = {
      version: DRUGS_CACHE_VERSION,
      timestamp: Date.now(),
      drugsList,
      drugsMap: Array.from(drugsMap.entries())
    }
    localStorage.setItem(DRUGS_CACHE_KEY, JSON.stringify(cacheData))
    console.log('💾 Сохранили список препаратов в localStorage:', drugsList.length, 'препаратов')
  } catch (error) {
    console.warn('⚠️ Не удалось сохранить кэш препаратов:', error)
  }
}

function loadDrugsFromCache(): { drugsList: string[]; drugsMap: Map<string, { id: string; name: string; variants: string[] }> } | null {
  if (!process.client) return null
  
  try {
    const cached = localStorage.getItem(DRUGS_CACHE_KEY)
    if (!cached) return null
    
    const cacheData = JSON.parse(cached)
    
    // Проверяем версию кэша
    if (cacheData.version !== DRUGS_CACHE_VERSION) {
      console.log('🔄 Версия кэша устарела, очищаем кэш')
      localStorage.removeItem(DRUGS_CACHE_KEY)
      return null
    }
    
    // Проверяем срок действия кэша
    const now = Date.now()
    if (now - cacheData.timestamp > DRUGS_CACHE_EXPIRY) {
      console.log('⏰ Кэш препаратов устарел, очищаем кэш')
      localStorage.removeItem(DRUGS_CACHE_KEY)
      return null
    }
    
    // Восстанавливаем данные
    const drugsMap = new Map(cacheData.drugsMap as Array<[string, { id: string; name: string; variants: string[] }]>)
    console.log('📦 Загрузили список препаратов из кэша:', cacheData.drugsList.length, 'препаратов')
    console.log('📦 Карта препаратов из кэша:', drugsMap.size, 'записей')
    
    return {
      drugsList: cacheData.drugsList,
      drugsMap
    }
  } catch (error) {
    console.warn('⚠️ Ошибка при загрузке кэша препаратов:', error)
    localStorage.removeItem(DRUGS_CACHE_KEY)
    return null
  }
}

// Функция для очистки кэша препаратов (полезна для отладки)
function clearDrugsCache() {
  if (!process.client) return
  
  try {
    localStorage.removeItem(DRUGS_CACHE_KEY)
    console.log('🗑️ Очистили кэш препаратов')
  } catch (error) {
    console.warn('⚠️ Не удалось очистить кэш препаратов:', error)
  }
}

const updateMobileStatus = () => {
  if (process.client) {
    isMobileDevice.value = window.innerWidth < 768
  }
}

onMounted(async () => {
  updateMobileStatus()
  window.addEventListener('resize', updateMobileStatus)
  
  // Добавляем глобальную функцию для очистки кэша (для отладки)
  if (process.client) {
    (window as any).clearDrugsCache = clearDrugsCache
    console.log('🔧 Для очистки кэша препаратов используйте: clearDrugsCache()')
  console.log('🔧 Версия файла: 2.0 - делегирование событий')
  }
  
  // Загружаем список препаратов для выделения
  await loadDrugsList()
  
  // После загрузки списка препаратов обрабатываем ссылки
  await nextTick()
  enhanceContentLinks()
  enhanceTableLinks()
  
  // Удаляем глобальный обработчик - используем только делегированный
  console.log('🔄 Используем только делегированный обработчик событий')
})

onBeforeUnmount(() => {
  if (process.client) {
    window.removeEventListener('resize', updateMobileStatus)
  }
})
type AlgorithmCategoryLite = { name: string; section?: string }
type AlgorithmItem = {
  _id: string
  title: string
  section?: string
  category?: AlgorithmCategoryLite
  content?: string
  mkbCodes?: string[]
  mkbExclusions?: string[]
}
type AlgorithmResponse = { success: true; item: AlgorithmItem } | { success: false; message: string }
const { data, pending, error } = await useFetch<AlgorithmResponse>(`/api/algorithms/${id}`)

// Отладочная информация
watchEffect(() => {
  console.log('🔍 Состояние загрузки алгоритма:', {
    pending: pending.value,
    hasData: !!data.value,
    data: data.value,
    error: error.value,
    id: id
  })
})
function isSuccess(resp: AlgorithmResponse | null | undefined): resp is { success: true; item: AlgorithmItem } {
  return !!resp && (resp as any).success === true && 'item' in (resp as any)
}
const algo = computed<AlgorithmItem | undefined>(() => {
  const result = isSuccess(data.value) ? data.value!.item : undefined
  console.log('🔍 Computed algo:', result)
  return result
})
// Принудительное обновление для перепарсинга при загрузке препаратов
const forceUpdate = ref(0)

// Простой подход: обработанный контент
const processedContent = ref<string>('')
  
const rendered = computed(() => {
  const raw = (algo.value?.content || '') as string
  
  // Если контент уже обработан, возвращаем его
  if (processedContent.value) {
    return processedContent.value
  }
  
  // Парсим markdown
  let html: string
  try { 
    html = marked.parse(raw) as string
  } catch { 
    html = raw
  }
  
  return html
})

// Простой watcher: обрабатываем контент только один раз при загрузке препаратов
watch([drugsList, drugsMap], ([newDrugsList, newDrugsMap]) => {
  if (newDrugsList && newDrugsList.length > 0 && newDrugsMap && newDrugsMap.size > 0) {
    console.log('🔄 Препараты загружены, обрабатываем контент...')
    
    const raw = (algo.value?.content || '') as string
    if (!raw) return
    
    // Парсим markdown
    let html: string
    try { 
      html = marked.parse(raw) as string
    } catch { 
      html = raw
    }
    
    // Обрабатываем препараты
    const processedHtml = parseDrugsInContent(html)
    processedContent.value = processedHtml
    
    console.log('✅ Контент обработан с препаратами')
  }
}, { immediate: true })

// Отображение кодов МКБ:
// - Явные диапазоны (A00–A02) — как есть
// - Базовые категории без подкатегории (A00, E14) — склеиваем в диапазоны по последовательности
// - Подкоды (A00.1, E10.2) — всегда показываем отдельно
const displayMkbChips = computed(() => {
  const src = (algo.value?.mkbCodes || []) as string[]
  const items = (src || []).map(s => String(s).trim().toUpperCase()).filter(Boolean)

  const explicitRanges: string[] = []
  const baseOnly: string[] = []
  const subcodes: string[] = []
  for (const s of items) {
    if (/[\-–]/.test(s)) explicitRanges.push(s)
    else if (/^[A-Z]\d{2}$/.test(s)) baseOnly.push(s)
    else subcodes.push(s)
  }

  // Группируем только baseOnly по букве, склеиваем последовательные номера в диапазоны
  const byLetter: Record<string, number[]> = {}
  for (const base of baseOnly) {
    const letter = base[0]
    const num = parseInt(base.slice(1), 10)
    ;(byLetter[letter] ||= []).push(num)
  }
  const categoryRanges: string[] = []
  for (const letter of Object.keys(byLetter).sort()) {
    const nums = Array.from(new Set(byLetter[letter])).sort((a, b) => a - b)
    let start = nums[0]
    let prev = nums[0]
    for (let i = 1; i <= nums.length; i++) {
      const cur = nums[i]
      const isContiguous = cur === prev + 1
      if (!isContiguous) {
        if (start === prev) categoryRanges.push(`${letter}${String(start).padStart(2, '0')}`)
        else categoryRanges.push(`${letter}${String(start).padStart(2, '0')}-${letter}${String(prev).padStart(2, '0')}`)
        start = cur
      }
      prev = cur
    }
  }

  return [...categoryRanges, ...explicitRanges, ...subcodes]
})

// Если в query указан другой раздел, а текущий алгоритм из иного раздела —
// найдём аналог по категории и названию и перенаправим на корректный id
const mapSectionParamToRu = (s?: string): 'Взрослые' | 'Детские' | 'ОНМП' | undefined => {
  if (!s) return undefined
  const m: Record<string, 'Взрослые'|'Детские'|'ОНМП'> = {
    adults: 'Взрослые', Adults: 'Взрослые', 'Взрослые': 'Взрослые',
    pediatrics: 'Детские', Pediatrics: 'Детские', 'Детские': 'Детские',
    onmp: 'ОНМП', ONMP: 'ОНМП', 'ОНМП': 'ОНМП',
    'onmp-children': 'Детские', 'ОНМП Дети': 'Детские'
  }
  return m[s] || undefined
}

// Функция для получения отображаемого названия раздела
const getSectionDisplayName = (section?: string): string => {
  if (!section) return ''
  
  // Если это уже читаемое название, возвращаем как есть
  if (['Взрослые', 'Детские', 'ОНМП'].includes(section)) {
    return section
  }
  
  // Мапим ID или slug на читаемые названия
  const sectionMap: Record<string, string> = {
    '68e7e174e4dff2c63511df9b': 'Взрослые',
    '68e7e174e4dff2c63511df9c': 'Детские', 
    '68e7e174e4dff2c63511df9d': 'ОНМП',
    '68e7e174e4dff2c63511dfa3': 'Детские',
    'adults': 'Взрослые',
    'pediatrics': 'Детские',
    'onmp': 'ОНМП',
    'onmp-children': 'Детские'
  }
  
  return sectionMap[section] || section
}

function normalizeTitleForMatch(t: string): string {
  return t.replace(/\s*\(дети\)\s*$/i, '').trim()
}

watch(algo, async (val: AlgorithmItem | undefined) => {
  const q = route.query?.section as string | undefined
  const desiredSection = mapSectionParamToRu(q)
  if (!val || !desiredSection) return
  if (val.section === desiredSection) return
  const categoryId = (val.category as any)?._id
  if (!categoryId) return
  try {
    const res: any = await $fetch('/api/algorithms', {
      query: { page: 1, limit: 200, category: categoryId, section: desiredSection, sortBy: 'createdAt', sortOrder: 'asc' },
      server: false
    })
    const list: any[] = res?.items || []
    const base = normalizeTitleForMatch(val.title || '')
    // Точное совпадение по базовому названию или начинается так же
    const candidate = list.find(a => normalizeTitleForMatch(a.title || '') === base) 
      || list.find(a => (a.title || '').toLowerCase().startsWith(base.toLowerCase()))
      || list[0]
    if (candidate && candidate._id && candidate._id !== val._id) {
      await navigateTo(`/algorithms/${route.params.section}/${route.params.category}/${candidate._id}`)
    }
  } catch (e) {
    console.warn('Не удалось переключить раздел просмотра алгоритма:', e)
  }
}, { immediate: true })

// Функция для открытия страницы кодификатора с проверкой кода МКБ
const diagModalOpen = ref(false)
const selectedDiagnosis = ref<any | null>(null)

// Функциональность закладок
const isBookmarked = ref(false)
const userBookmarks = ref<any[]>([])

const loadBookmarks = async () => {
  try {
    const res: any = await $fetch('/api/bookmarks')
    if (res?.success) userBookmarks.value = res.items || []
  } catch {}
}

const buildMkbUrl = (diagnosis: any) => {
  return `/codifier?open=${diagnosis.mkbCode}`
}

const updateIsBookmarked = async () => {
  if (!selectedDiagnosis.value) { 
    isBookmarked.value = false
    return 
  }
  if (userBookmarks.value.length === 0) await loadBookmarks()
  const targetUrl = buildMkbUrl(selectedDiagnosis.value)
  isBookmarked.value = userBookmarks.value.some((b: any) => b.url === targetUrl)
}

const toggleBookmark = async () => {
  if (!selectedDiagnosis.value) return
  
  try {
    if (isBookmarked.value) {
      // Удаляем из закладок
      const targetUrl = buildMkbUrl(selectedDiagnosis.value)
      if (userBookmarks.value.length === 0) await loadBookmarks()
      const bm = userBookmarks.value.find((b: any) => b.url === targetUrl)
      if (bm?._id) {
        await $fetch(`/api/bookmarks/${bm._id}`, { method: 'DELETE' })
        userBookmarks.value = userBookmarks.value.filter((b: any) => b._id !== bm._id)
      }
      isBookmarked.value = false
    } else {
      // Добавляем в закладки
      await $fetch('/api/bookmarks', {
        method: 'POST',
        body: {
          type: 'mkb',
          title: selectedDiagnosis.value.name,
          description: selectedDiagnosis.value.mkbCode,
          category: 'МКБ-10',
          url: buildMkbUrl(selectedDiagnosis.value)
        }
      })
      isBookmarked.value = true
      await loadBookmarks() // Перезагружаем список
    }
  } catch (error) {
    console.error('Ошибка при работе с закладками:', error)
  }
}

// Проверяем статус закладки при выборе диагноза
watch(selectedDiagnosis, async (diagnosis) => {
  if (!diagnosis) {
    isBookmarked.value = false
    return
  }
  
  await updateIsBookmarked()
})

function normalizeMkbCode(raw: string): string {
  if (!raw) return ''
  const s = String(raw).trim()
  // Если есть скобки, пробуем взять содержимое последних скобок
  const inParens = s.match(/\(([^)]+)\)\s*$/)
  if (inParens && inParens[1]) return inParens[1].trim().toUpperCase()
  // Ищем шаблон кода МКБ вида A00 или A00.0
  const mk = s.match(/([A-Za-z][0-9]{2}(?:\.[0-9]+)?)/)
  if (mk && mk[1]) return mk[1].toUpperCase()
  return s.toUpperCase()
}

const openCodifierPage = async (code: string) => {
  try {
    // Диапазоны по-прежнему ведем на категорию кодификатора
    if (code.includes('–') || code.includes('-')) {
      const response: any = await $fetch(`/api/mkb/range/${encodeURIComponent(code)}`)
      if (response.success && response.category?.url) {
        await navigateTo(`/codifier/${response.category.url}`)
      }
      return
    }
    // Иначе — локальная модалка с данными диагноза по коду
    const mkb = normalizeMkbCode(code)
    const res: any = await $fetch(`/api/mkb/code/${encodeURIComponent(mkb)}`)
    if (res?.success && res.diagnosis) {
      selectedDiagnosis.value = res.diagnosis
      diagModalOpen.value = true
    } else {
      // Если конкретный диагноз не найден (например, базовая категория вроде E14),
      // открываем страницу кодификатора с правильной категорией
      try {
        const redir: any = await $fetch(`/api/mkb/redirect/${encodeURIComponent(mkb)}`)
        if (redir?.success && redir.redirectUrl) {
          await navigateTo(redir.redirectUrl)
          return
        }
        // Фолбэк: расширяем префикс как диапазон (E14-) и редиректим по первому найденному коду
        const exp: any = await $fetch('/api/mkb/expand', { query: { range: `${mkb}-` } })
        const first = (exp?.mkbCodes || [])[0]
        if (first) {
          const rd2: any = await $fetch(`/api/mkb/redirect/${encodeURIComponent(first)}`)
          if (rd2?.success && rd2.redirectUrl) {
            await navigateTo(rd2.redirectUrl)
            return
          }
        }
      } catch {}
      console.warn('Диагноз не найден по коду', mkb)
    }
  } catch (error) {
    console.error('Ошибка при открытии диагноза:', error)
  }
}

// Реактивные переменные для локального статуса
const localStatuses = ref<any[]>([])
const localStatusLoading = ref(false)

// Функция для открытия модального окна локального статуса
const openLocalStatusModal = () => {
  if (localStatuses.value.length > 0) {
    const firstStatus = localStatuses.value[0]
    
    // Если найден только один статус, открываем его в модалке
    if (localStatuses.value.length === 1) {
      if (firstStatus.category?.url) {
        navigateTo(`/local-statuses/${firstStatus.category.url}?open=${firstStatus._id}`)
      } else {
        navigateTo('/local-statuses')
      }
    } else {
      // Если найдено больше одного статуса, переходим на страницу категории
      if (firstStatus.category?.url) {
        navigateTo(`/local-statuses/${firstStatus.category.url}`)
      } else {
        navigateTo('/local-statuses')
      }
    }
  }
}

// Функция для расширения диапазонов кодов МКБ
const expandMkbRange = (code: string): string[] => {
  // Проверяем, является ли код диапазоном
  if (!code.includes('–') && !code.includes('-')) {
    return [code]
  }
  
  const separator = code.includes('–') ? '–' : '-'
  const [start, end] = code.split(separator).map(s => s.trim())
  
  if (!start || !end) {
    return [code]
  }
  
  // Извлекаем буквенную часть и числовую часть
  // Поддерживаем как полные коды (G30.0), так и базовые коды (G30)
  const startMatch = start.match(/^([A-Z])(\d+)(?:\.(\d+))?$/)
  
  // Для второй части диапазона может быть только число (например, "31" в "G30–31")
  // или полный код (например, "G31.0")
  let endMatch = end.match(/^([A-Z])(\d+)(?:\.(\d+))?$/)
  
  // Если вторая часть содержит только число, используем букву из первой части
  if (!endMatch && /^\d+$/.test(end)) {
    const [, startLetter] = startMatch!
    endMatch = [end, startLetter, end, undefined] as RegExpMatchArray
  }
  
  if (!startMatch || !endMatch) {
    return [code]
  }
  
  const [, startLetter, startNum, startSub] = startMatch
  const [, endLetter, endNum, endSub] = endMatch
  
  // Проверяем, что буквы совпадают
  if (startLetter !== endLetter) {
    return [code]
  }
  
  const expandedCodes: string[] = []
  const startNumber = parseInt(startNum)
  const endNumber = parseInt(endNum)
  
  for (let num = startNumber; num <= endNumber; num++) {
    const numStr = num.toString().padStart(2, '0')
    
    if (num === startNumber && num === endNumber) {
      // Одинаковый номер - добавляем все подкоды от startSub до endSub
      const startSubNum = startSub ? parseInt(startSub) : 0
      const endSubNum = endSub ? parseInt(endSub) : 9
      
      for (let sub = startSubNum; sub <= endSubNum; sub++) {
        expandedCodes.push(`${startLetter}${numStr}.${sub}`)
      }
    } else if (num === startNumber) {
      // Первый номер - добавляем все подкоды от startSub до 9
      const startSubNum = startSub ? parseInt(startSub) : 0
      
      for (let sub = startSubNum; sub <= 9; sub++) {
        expandedCodes.push(`${startLetter}${numStr}.${sub}`)
      }
    } else if (num === endNumber) {
      // Последний номер - добавляем все подкоды от 0 до endSub
      const endSubNum = endSub ? parseInt(endSub) : 9
      
      for (let sub = 0; sub <= endSubNum; sub++) {
        expandedCodes.push(`${startLetter}${numStr}.${sub}`)
      }
    } else {
      // Средние номера - добавляем все подкоды от 0 до 9
      for (let sub = 0; sub <= 9; sub++) {
        expandedCodes.push(`${startLetter}${numStr}.${sub}`)
      }
    }
  }
  
  return expandedCodes
}

// Функция для поиска локальных статусов по кодам МКБ
const searchLocalStatuses = async () => {
  if (!algo.value?.mkbCodes || algo.value.mkbCodes.length === 0) {
    localStatuses.value = []
    return
  }

  localStatusLoading.value = true
  
  try {
    // Расширяем все диапазоны кодов МКБ
    const expandedCodes: string[] = []
    for (const code of algo.value.mkbCodes) {
      expandedCodes.push(...expandMkbRange(code))
    }
    
    
    const response: any = await $fetch('/api/local-statuses/search-by-mkb', {
      method: 'POST',
      body: {
        mkbCodes: expandedCodes
      }
    })
    
    if (response.success) {
      localStatuses.value = response.localStatuses || []
    } else {
      console.error('Ошибка при поиске локальных статусов:', response.message)
      localStatuses.value = []
    }
  } catch (error) {
    console.error('Ошибка при поиске локальных статусов:', error)
    localStatuses.value = []
  } finally {
    localStatusLoading.value = false
  }
}

// Функция для открытия локального статуса
const openLocalStatus = (status: any) => {
  if (status.category?.url) {
    navigateTo(`/local-statuses/${status.category.url}`)
  } else {
    navigateTo('/local-statuses')
  }
}


// Стилизация таблиц в контенте под стиль Nuxt UI Table
const contentRef = ref<HTMLElement | null>(null)
function styleTables() {
  const root = contentRef.value
  if (!root) return
  const tables = Array.from(root.querySelectorAll('table')) as HTMLTableElement[]
  for (const table of tables) {
    // Обёртка для внешнего бордера и скруглений (идемпотентно)
    const alreadyWrapped = table.closest('[data-styled-table-wrapper]') as HTMLElement | null
    if (!alreadyWrapped) {
      const wrapper = document.createElement('div')
      wrapper.setAttribute('data-styled-table-wrapper', '')
      wrapper.classList.add('my-3', 'bg-white', 'dark:bg-slate-800', 'border', 'border-slate-100', 'dark:border-slate-700', 'rounded-lg', 'overflow-x-hidden', 'relative', 'sticky-container')
      table.parentElement?.insertBefore(wrapper, table)
      wrapper.appendChild(table)
    }
    // Стили только для содержимого таблицы, без внешнего бордера
    table.classList.remove('border', 'border-slate-100', 'dark:border-slate-700', 'rounded-lg', 'rounded-md', 'overflow-hidden')
    table.classList.add('w-full', 'table-fixed', 'border-0', 'bg-transparent')
    table.style.tableLayout = 'fixed'
    const thead = table.querySelector('thead')
    const tbody = table.querySelector('tbody')
    if (thead) thead.classList.add('bg-slate-100', 'dark:bg-slate-800', 'border-b', 'border-slate-100', 'dark:border-slate-700', 'sticky', 'top-0', 'z-20')
    if (tbody) tbody.classList.add('divide-y', 'divide-slate-100', 'dark:divide-slate-700')
    // Равномерное распределение 3 колонок + перенос текста
    table.querySelectorAll('colgroup col').forEach(col => (col as HTMLElement).style.width = '33.3333%')
    table.querySelectorAll('th').forEach(th => {
      th.classList.remove('text-left', 'align-top', 'h-[85px]')
      th.classList.add('px-4', 'py-3', 'text-sm', 'text-slate-600', 'dark:text-slate-300', 'text-center', 'font-medium', 'whitespace-normal', 'break-words', 'align-middle', 'sticky', 'top-0', 'z-20', 'bg-slate-200', 'dark:bg-slate-800')
    })
    table.querySelectorAll('td').forEach(td => {
      td.classList.add('p-4', 'text-sm', 'text-slate-600', 'dark:text-slate-300', 'whitespace-normal', 'break-words', 'align-top', 'bg-white', 'dark:bg-slate-800')
    })
    table.querySelectorAll('tr').forEach(tr => tr.classList.add('hover:bg-slate-50/60', 'dark:hover:bg-slate-700/40'))
    // Бордеры: у первой колонки справа, у второй слева и справа на md+ экранах
    table.querySelectorAll('thead tr').forEach(tr => {
      const cells = Array.from(tr.children) as HTMLElement[]
      if (cells[0]) cells[0].classList.add('border-r', 'border-slate-100', 'dark:border-slate-700')
      if (cells[1]) {
        cells[1].classList.add('border-l', 'border-slate-100', 'dark:border-slate-700')
        cells[1].classList.add('md:border-r', 'md:border-slate-100', 'md:dark:border-slate-700')
      }
    })
    table.querySelectorAll('tbody tr').forEach(tr => {
      const cells = Array.from(tr.children) as HTMLElement[]
      if (cells[0]) cells[0].classList.add('border-r', 'border-slate-100', 'dark:border-slate-700')
      if (cells[1]) {
        cells[1].classList.add('border-l', 'border-slate-100', 'dark:border-slate-700')
        cells[1].classList.add('md:border-r', 'md:border-slate-100', 'md:dark:border-slate-700')
      }
    })

    // Мобильный режим: показывать 2 колонки, первая + переключаемая (2/3) свайпом
    setupMobileTwoColumn(table)
  }
}

onMounted(() => nextTick(styleTables))
watch(rendered, async () => { 
  await nextTick()
  // Стилизуем таблицы
  styleTables() 
})

// ===== Мобильная логика двух колонок и свайпа =====
function isMobile() {
  if (typeof window === 'undefined') return false
  return window.matchMedia('(max-width: 767px)').matches
}


function applyMobileTwoColumnView(wrapper: HTMLElement, table: HTMLTableElement) {
  const mobileTarget = wrapper.getAttribute('data-mobile-col') === '3' ? 3 : 2
  const rows = table.querySelectorAll('thead tr, tbody tr')
  const colgroup = table.querySelector('colgroup') as HTMLElement | null
  const cols = colgroup ? Array.from(colgroup.querySelectorAll('col')) as HTMLElement[] : []


  // Создаем индикаторы точек в шапке таблицы
  if (isMobile()) {
    const thead = table.querySelector('thead')
    if (thead) {
      let dotsContainer = thead.querySelector('[data-mobile-dots-container]') as HTMLElement | null
      if (!dotsContainer) {
        dotsContainer = document.createElement('div')
        dotsContainer.setAttribute('data-mobile-dots-container', '1')
        dotsContainer.classList.add('md:hidden', 'absolute', 'right-2', 'top-1/2', '-translate-y-1/2', 'flex', 'items-center', 'gap-1', 'z-30', 'pointer-events-none', 'bg-slate-100', 'dark:bg-slate-800', 'p-1', 'rounded-full')
        
        const dot2 = document.createElement('span')
        dot2.setAttribute('data-dot', '2')
        dot2.classList.add('inline-block', 'w-1.5', 'h-1.5', 'rounded-full')
        
        const dot3 = document.createElement('span')
        dot3.setAttribute('data-dot', '3')
        dot3.classList.add('inline-block', 'w-1.5', 'h-1.5', 'rounded-full')
        
        dotsContainer.appendChild(dot2)
        dotsContainer.appendChild(dot3)
        thead.appendChild(dotsContainer)
      }
    
      // Активируем соответствующую точку
      const dot2 = dotsContainer.querySelector('[data-dot="2"]') as HTMLElement | null
      const dot3 = dotsContainer.querySelector('[data-dot="3"]') as HTMLElement | null
      const activeCls = ['bg-slate-600', 'dark:bg-slate-200']
      const inactiveCls = ['bg-slate-300', 'dark:bg-slate-600']
      
      if (dot2 && dot3) {
        if (mobileTarget === 2) {
          dot2.classList.add(...activeCls)
          dot2.classList.remove(...inactiveCls)
          dot3.classList.add(...inactiveCls)
          dot3.classList.remove(...activeCls)
        } else {
          dot3.classList.add(...activeCls)
          dot3.classList.remove(...inactiveCls)
          dot2.classList.add(...inactiveCls)
          dot2.classList.remove(...activeCls)
        }
      }
    }
    // На мобильных: 2 колонки (первая 35% + выбранная 65%), фиксированная раскладка
    table.style.tableLayout = 'fixed'
    cols.forEach((c, idx) => {
      // ширины колонок на мобилках
      if (idx === 0) c.style.width = '35%'
      if (idx === 1) {
        c.style.width = '65%'
        c.style.display = mobileTarget === 2 ? '' : 'none'
      }
      if (idx === 2) {
        c.style.width = '65%'
        c.style.display = mobileTarget === 3 ? '' : 'none'
      }
    })

    rows.forEach((tr, rowIndex) => {
      const cells = Array.from(tr.children) as HTMLElement[]
      const isHead = !!(tr.parentElement && tr.parentElement.tagName.toLowerCase() === 'thead')
      
      if (cells[0]) {
        cells[0].classList.remove('hidden', 'w-0', 'p-0')
        cells[0].style.width = '35%'
        cells[0].style.maxWidth = '35%'
        
        // Для заголовков добавляем стили обрезки текста
        if (isHead && cells[0].tagName === 'TH') {
          cells[0].classList.add('whitespace-nowrap', 'overflow-hidden', 'text-ellipsis')
        }
      }
      
      if (cells[1]) {
        const hide = mobileTarget !== 2
        cells[1].classList.toggle('hidden', hide)
        cells[1].classList.toggle('w-0', hide)
        cells[1].classList.toggle('p-0', hide)
        cells[1].style.width = hide ? '' : '65%'
        cells[1].style.maxWidth = hide ? '' : '65%'
        
        // Для заголовков добавляем стили обрезки текста
        if (isHead && cells[1].tagName === 'TH') {
          cells[1].classList.add('whitespace-nowrap', 'overflow-hidden', 'text-ellipsis')
        }
      }
      
      if (cells[2]) {
        const hide = mobileTarget !== 3
        cells[2].classList.toggle('hidden', hide)
        cells[2].classList.toggle('w-0', hide)
        cells[2].classList.toggle('p-0', hide)
        cells[2].style.width = hide ? '' : '65%'
        cells[2].style.maxWidth = hide ? '' : '65%'
        
        // Для заголовков добавляем стили обрезки текста
        if (isHead && cells[2].tagName === 'TH') {
          cells[2].classList.add('whitespace-nowrap', 'overflow-hidden', 'text-ellipsis')
        }
      }
    })
  } else {
    // Десктоп: возвращаем 3 колонки и фиксированную ширину
    table.style.tableLayout = 'fixed'
    if (cols.length === 3) {
      cols.forEach((c, idx) => {
        c.style.display = ''
        // Первая колонка фикс 30%, остальные — авто
        if (idx === 0) c.style.width = '30%'
        else c.style.width = ''
      })
    }
    
    // Убираем индикаторы точек на десктопе
    const thead = table.querySelector('thead')
    if (thead) {
      const dotsContainer = thead.querySelector('[data-mobile-dots-container]') as HTMLElement | null
      if (dotsContainer) dotsContainer.remove()
    }
    rows.forEach((tr) => {
      const cells = Array.from(tr.children) as HTMLElement[]
      const isHead = !!(tr.parentElement && tr.parentElement.tagName.toLowerCase() === 'thead')
      
      if (cells[0]) { 
        cells[0].classList.remove('hidden', 'w-0', 'p-0'); 
        // Фиксированная ширина первой колонки на десктопе
        cells[0].style.width = '30%'
        cells[0].style.maxWidth = '30%'
        // Убираем стили обрезки текста для десктопа
        if (isHead && cells[0].tagName === 'TH') {
          cells[0].classList.remove('whitespace-nowrap', 'overflow-hidden', 'text-ellipsis')
        }
      }
      if (cells[1]) {
        cells[1].classList.remove('hidden', 'w-0', 'p-0'); 
        cells[1].style.width = ''
        // Убираем стили обрезки текста и индикаторы для десктопа
        if (isHead && cells[1].tagName === 'TH') {
          cells[1].classList.remove('whitespace-nowrap', 'overflow-hidden', 'text-ellipsis', 'relative')
          const dots = cells[1].querySelector('[data-mobile-dots]') as HTMLElement | null
          if (dots) dots.remove()
        }
      }
      if (cells[2]) {
        cells[2].classList.remove('hidden', 'w-0', 'p-0'); 
        cells[2].style.width = ''
        // Убираем стили обрезки текста для десктопа
        if (isHead && cells[2].tagName === 'TH') {
          cells[2].classList.remove('whitespace-nowrap', 'overflow-hidden', 'text-ellipsis')
        }
      }
    })
  }
}

function setupMobileTwoColumn(table: HTMLTableElement) {
  const wrapper = table.closest('[data-styled-table-wrapper]') as HTMLElement | null
  if (!wrapper) return
  if (wrapper.getAttribute('data-mobile-init') === '1') {
    // Обновим отображение при повторном вызове (напр., при ререндере)
    applyMobileTwoColumnView(wrapper, table)
    return
  }
  wrapper.setAttribute('data-mobile-init', '1')
  // По умолчанию показываем 2-ю колонку на мобильных
  if (!wrapper.getAttribute('data-mobile-col')) wrapper.setAttribute('data-mobile-col', '2')

  // Обработчики свайпов
  let touchStartX = 0
  let touchStartY = 0
  let touchStartTs = 0
  let isDragging = false
  let lastDx = 0
  const minDistance = 60 // пикселей
  wrapper.style.touchAction = 'pan-y'
  wrapper.addEventListener('touchstart', (e: TouchEvent) => {
    if (!e.touches || e.touches.length === 0) return
    const t = e.touches[0]
    touchStartX = t.clientX
    touchStartY = t.clientY
    touchStartTs = Date.now()
    isDragging = true
    lastDx = 0
  }, { passive: true })
  wrapper.addEventListener('touchmove', (e: TouchEvent) => {
    if (!isMobile() || !isDragging) return
    if (!e.touches || e.touches.length === 0) return
    const t = e.touches[0]
    const dx = t.clientX - touchStartX
    const dy = t.clientY - touchStartY
    // Только горизонтальный доминирующий жест
    if (Math.abs(dx) <= Math.abs(dy) * 1.2) return
    lastDx = dx
  }, { passive: true })

  wrapper.addEventListener('touchend', (e: TouchEvent) => {
    if (!isMobile()) return
    if (!e.changedTouches || e.changedTouches.length === 0) return
    const t = e.changedTouches[0]
    const dx = t.clientX - touchStartX
    const dy = t.clientY - touchStartY
    const dt = Date.now() - touchStartTs
    // Условия для валидного горизонтального свайпа
    const maxDuration = 600 // мс
    const horizontalDominance = Math.abs(dx) > Math.abs(dy) * 1.5
    const shouldSwitch = Math.abs(dx) >= minDistance && horizontalDominance && dt <= maxDuration
    
    if (shouldSwitch) {
      if (dx < 0) wrapper.setAttribute('data-mobile-col', '3')
      else wrapper.setAttribute('data-mobile-col', '2')
      
      applyMobileTwoColumnView(wrapper, table)
    }
    isDragging = false
  }, { passive: true })

  // На ресайз восстанавливаем/применяем вид
  const onResize = () => applyMobileTwoColumnView(wrapper, table)
  window.addEventListener('resize', onResize)
  // Сохраняем слушатель, чтобы снять при размонтировании
  const existing = (contentRef.value as any)
  ;(existing.__mobileResizeHandlers ||= []).push(onResize)

  // Начальная отрисовка
  applyMobileTwoColumnView(wrapper, table)
}

// ===== Перехват внутренних ссылок вида /algorithms/adults/1.anesthesiology/2.successful-cpr =====
function stripNumberPrefix(s: string): string {
  return s.replace(/^\d+\./, '')
}
function mapSectionSlug(slug: string): 'Взрослые'|'Детские'|'ОНМП'|undefined {
  if (slug === 'adults') return 'Взрослые'
  if (slug === 'pediatrics') return 'Детские'
  if (slug === 'onmp') return 'ОНМП'
  if (slug === 'onmp-children') return 'Детские'
  return undefined
}
async function navigateOldAlgoLink(href: string, anchorText: string) {
  console.log('🚀 navigateOldAlgoLink ВЫЗВАНА!', href, 'текст:', anchorText)
  try {
    const url = new URL(href, window.location.origin)
    const parts = url.pathname.split('/').filter(Boolean)
    console.log('🔍 Части URL:', parts)
    // Ожидаемый формат: /algorithms/:section/:categoryFolder[/ :algoFile]
    if (parts[0] !== 'algorithms') return
    const sectionSlug = parts[1]
    const sectionName = mapSectionSlug(sectionSlug)
    console.log('🔍 Секция:', sectionSlug, '->', sectionName)
    if (!sectionName) return
    const categoryUrl = stripNumberPrefix(parts[2] || '')
    console.log('🔍 Категория URL:', categoryUrl)
    if (!categoryUrl) return

    // Если указан файл алгоритма, попробуем найти по тексту ссылки (в скобках) внутри категории
    const hasAlgo = parts.length >= 4
    if (hasAlgo) {
      // Если есть ID алгоритма в URL (последний сегмент), используем его напрямую
      const algorithmId = parts[parts.length - 1]
      console.log('🔍 ID алгоритма из URL:', algorithmId)
      
      if (algorithmId && algorithmId.length === 24) { // MongoDB ObjectId имеет 24 символа
        console.log('🔍 Переходим напрямую по ID:', algorithmId)
        // Строим правильный путь без /view/
        const targetUrl = `/algorithms/${sectionSlug}/${categoryUrl}/${algorithmId}`
        console.log('🔍 Целевой URL:', targetUrl)
        await navigateTo(targetUrl)
        return
      }
      
      // Если ID невалидный, но есть /view/ в пути, попробуем извлечь ID из предыдущего сегмента
      if (href.includes('/view/')) {
        const viewIndex = parts.indexOf('view')
        console.log('🔍 Индекс view в частях URL:', viewIndex, 'части:', parts)
        if (viewIndex !== -1 && viewIndex + 1 < parts.length) {
          const realId = parts[viewIndex + 1]
          console.log('🔍 Найден ID после /view/:', realId)
          if (realId && realId.length === 24) {
            console.log('🔍 Переходим по ID после /view/:', realId)
            const targetUrl = `/algorithms/${sectionSlug}/${categoryUrl}/${realId}`
            console.log('🔍 Целевой URL:', targetUrl)
            await navigateTo(targetUrl)
            return
          }
        }
      }
      
      // Если ID нет или он неверный, ищем по названию
      const m = anchorText.match(/\(([^)]+)\)/)
      const title = (m ? m[1] : anchorText).trim()
      console.log('🔍 Ищем алгоритм по названию:', title)
      
      // Сначала получим категорию
      const catRes: any = await $fetch(`/api/algorithms/categories/by-url/${categoryUrl}`)
      const catId = catRes?.item?._id
      if (catId) {
        const listRes: any = await $fetch('/api/algorithms', {
          query: { page: 1, limit: 200, category: catId, section: sectionName, sortBy: 'createdAt', sortOrder: 'asc' }
        })
        const list: any[] = listRes?.items || []
        const found = list.find(a => String(a.title || '').toLowerCase() === title.toLowerCase())
          || list.find(a => String(a.title || '').toLowerCase().includes(title.toLowerCase()))
        if (found && found._id) {
          await navigateTo(`/algorithms/${sectionSlug}/${categoryUrl}/${found._id}`)
          return
        }
      }
    }
    // Фолбэк — перейти на список категории
    await navigateTo(`/algorithms/${sectionSlug}/${categoryUrl}`)
  } catch (e) {
    console.warn('Не удалось обработать старую ссылку алгоритма:', href, e)
  }
}
function enhanceContentLinks() {
  const root = contentRef.value
  if (!root) return
  
  // Сначала заменяем все ссылки с /view/ на правильные ссылки (НЕЗАВИСИМО от загрузки препаратов)
  const allLinks = Array.from(root.querySelectorAll('a[href*="/view/"]')) as HTMLAnchorElement[]
  console.log('🔍 Найдено ссылок с /view/:', allLinks.length)
  
  for (const link of allLinks) {
    const href = link.getAttribute('href') || ''
    if (href.includes('/view/')) {
      const newHref = href.replace('/view/', '/')
      link.setAttribute('href', newHref)
      console.log('🔄 Заменили ссылку:', href, '→', newHref)
    }
  }
  
  // Дополнительно заменяем /view/ в текстовом содержимом HTML
  const htmlContent = root.innerHTML
  if (htmlContent.includes('/view/')) {
    const newHtmlContent = htmlContent.replace(/\/view\//g, '/')
    root.innerHTML = newHtmlContent
    console.log('🔄 Заменили /view/ в HTML содержимом')
    
    // После замены HTML содержимого, еще раз проверим ссылки
    const updatedLinks = Array.from(root.querySelectorAll('a[href*="/view/"]')) as HTMLAnchorElement[]
    console.log('🔍 После замены HTML найдено ссылок с /view/:', updatedLinks.length)
    
    for (const link of updatedLinks) {
      const href = link.getAttribute('href') || ''
      if (href.includes('/view/')) {
        const newHref = href.replace('/view/', '/')
        link.setAttribute('href', newHref)
        console.log('🔄 Дополнительно заменили ссылку:', href, '→', newHref)
      }
    }
  }
  
  // Если список препаратов еще не загружен, не обрабатываем остальные ссылки
  if (!drugsList.value || drugsList.value.length === 0) {
    console.log('Список препаратов еще не загружен, пропускаем обработку остальных ссылок')
    return
  }
  
  // Используем делегирование событий для ссылок на препараты
  const drugLinks = Array.from(root.querySelectorAll('a.algocclink[data-drug-name]')) as HTMLAnchorElement[]
  console.log('🔍 Найдено ссылок на препараты:', drugLinks.length)
  
  // Удаляем старые обработчики если они есть
  if (root.hasAttribute('data-drug-handler-added')) {
    console.log('🔄 Удаляем старый обработчик событий')
    root.removeAttribute('data-drug-handler-added')
  }
  
  // Добавляем один обработчик на контейнер для всех ссылок на препараты
  console.log('🔄 Добавляем делегированный обработчик клика для ссылок на препараты')
    
    root.addEventListener('click', (ev) => {
      
      const target = ev.target as HTMLElement
      console.log('🖱️ Клик по элементу:', target.tagName, target.className)
      const link = target.closest('a.algocclink[data-drug-name]') as HTMLAnchorElement
      
      if (link) {
        console.log('🖱️ Делегированный обработчик клика сработал для препарата:', link.getAttribute('data-drug-name'))
        console.log('🖱️ Версия обработчика: 2.0 - делегирование событий')
        
        // Останавливаем событие сразу
        ev.preventDefault()
        ev.stopPropagation()
        ev.stopImmediatePropagation()
        
        const drugId = link.getAttribute('data-drug-id')
      const drugName = link.getAttribute('data-drug-name')
        console.log('🖱️ Клик по ссылке на препарат:', drugName, 'ID:', drugId)
        
        if (drugId) {
          const currentTime = Date.now()
          
          console.log('🔍 Состояние перед обработкой клика:', {
            drugId,
            currentTime,
            lastClickTime: lastClickTime.value,
            lastClickDrugId: lastClickDrugId.value,
            drugsOpen: drugsOpen.value,
            drugsQuery: drugsQuery.value
          })
          
          // Проверяем, не слишком ли быстро повторный клик (менее 100мс)
          if (currentTime - lastClickTime.value < 100 && lastClickDrugId.value === drugId) {
            console.log('⚠️ Слишком быстрый повторный клик, игнорируем')
            return
          }
          
          // Проверяем, не открыта ли уже модалка с этим препаратом
          if (drugsOpen.value && drugsQuery.value === drugId) {
            console.log('⚠️ Модалка уже открыта с этим препаратом, игнорируем клик')
            return
          }
          
          // Если модалка закрыта, но query еще не очищен, очищаем его
          if (!drugsOpen.value && drugsQuery.value) {
            console.log('🔄 Очищаем старый query при закрытой модалке')
            drugsQuery.value = ''
          }
          
          // Обновляем время и ID последнего клика
          lastClickTime.value = currentTime
          lastClickDrugId.value = drugId
          
          // Устанавливаем состояние модалки
          drugsQuery.value = drugId
          drugsOpen.value = true
          console.log('🔄 Открываем модалку с препаратом по ID:', drugId)
          console.log('🔍 Состояние после установки:', {
            drugsOpen: drugsOpen.value,
            drugsQuery: drugsQuery.value
          })
        }
      }
    }, { passive: false, capture: true })
    
    root.setAttribute('data-drug-handler-added', 'true')
    console.log('🔄 Добавили делегированный обработчик для ссылок на препараты (версия 2.0)')
  
  // Обработка ссылок на алгоритмы (включая те, что имеют класс algocclink, но являются ссылками на алгоритмы)
  const algorithmLinks = Array.from(root.querySelectorAll('a[href*="/algorithms/"]')) as HTMLAnchorElement[]
  console.log('Найдено ссылок на алгоритмы:', algorithmLinks.length)
  
  for (const link of algorithmLinks) {
    const href = link.getAttribute('href') || ''
    const hrefParts = href.split('/').filter(Boolean)
    
    console.log('Обрабатываем ссылку:', href, 'сегменты:', hrefParts)
    
    // Проверяем, является ли это ссылкой на препарат (имеет класс algocclink и data-drug-name)
    const isDrugLink = link.classList.contains('algocclink') && link.hasAttribute('data-drug-name')
    
    // Проверяем, является ли это ссылкой на конкретный алгоритм (4+ сегментов и НЕ ссылка на препарат)
    const isAlgorithmLink = hrefParts.length >= 4 && hrefParts[0] === 'algorithms' && !isDrugLink
    
    console.log('isAlgorithmLink:', isAlgorithmLink, 'isDrugLink:', isDrugLink)
    console.log('Класс ссылки:', link.className)
    console.log('data-drug-name:', link.getAttribute('data-drug-name'))
    
    if (isDrugLink) {
      console.log('Ссылка на препарат уже обработана выше:', href)
    } else if (isAlgorithmLink) {
      console.log('Добавляем обработчик для ссылки на алгоритм:', href)
      
      // Добавляем стили algocclink для ссылок на алгоритмы
      if (!link.classList.contains('algocclink')) {
        link.classList.add('algocclink', 'cursor-pointer')
        console.log('🎨 Добавили стили algocclink для ссылки на алгоритм:', href)
      }
      
      link.addEventListener('click', (ev) => {
        console.log('🖱️ Клик по ссылке на алгоритм!', href)
        ev.preventDefault()
        ev.stopPropagation()
        console.log('🖱️ Вызываем navigateOldAlgoLink...')
        void navigateOldAlgoLink(href, link.textContent || '')
      }, { passive: false, capture: true })
    }
  }
}

// Функция для обработки ссылок в таблицах
function enhanceTableLinks() {
  const root = contentRef.value
  if (!root) return
  
  // Находим все ссылки в таблицах
  const tableLinks = Array.from(root.querySelectorAll('table a[href*="/algorithms/"]')) as HTMLAnchorElement[]
  console.log('🔍 Найдено ссылок в таблицах:', tableLinks.length)
  
  for (const link of tableLinks) {
    const href = link.getAttribute('href') || ''
    console.log('🔍 Обрабатываем ссылку в таблице:', href)
    
    // Заменяем /view/ если есть
    if (href.includes('/view/')) {
      const newHref = href.replace('/view/', '/')
      link.setAttribute('href', newHref)
      console.log('🔄 Заменили ссылку в таблице:', href, '→', newHref)
    }
    
    // Добавляем стили для ссылок на алгоритмы (как у препаратов)
    if (href.includes('/algorithms/') && !link.classList.contains('algocclink')) {
      link.classList.add('algocclink', 'cursor-pointer')
      console.log('🎨 Добавили стили algocclink для ссылки на алгоритм в таблице:', href)
    }
    
    // Добавляем обработчик клика для ссылок на алгоритмы
    if (href.includes('/algorithms/') && !link.hasAttribute('data-drug-name')) {
      link.addEventListener('click', (ev) => {
        console.log('🖱️ Клик по ссылке на алгоритм в таблице!', href)
        ev.preventDefault()
        ev.stopPropagation()
        void navigateOldAlgoLink(href, link.textContent || '')
      }, { passive: false, capture: true })
    }
  }
}

// Функция для загрузки списка препаратов из базы данных
async function loadDrugsList() {
  if (drugsList.value.length > 0) return // Уже загружено
  
  // Сначала пытаемся загрузить из кэша
  const cachedData = loadDrugsFromCache()
  if (cachedData) {
    drugsList.value = cachedData.drugsList
    drugsMap.value = cachedData.drugsMap
    
    console.log('✅ Использовали кэшированные данные препаратов')
    return
  }
  
  console.log('Загружаем список препаратов с сервера...')
  try {
  const response: any = await $fetch('/api/drugs', { 
    query: { page: 1, limit: 1000 } 
  })
  console.log('Ответ API препаратов:', response)
    
    if (response?.items && Array.isArray(response.items)) {
      const drugNames: string[] = []
      const newDrugsMap = new Map<string, { id: string; name: string; variants: string[] }>()
      
      // Простая загрузка препаратов без создания множества вариантов
      for (const drug of response.items) {
        const drugId = drug._id
        const drugName = drug.name
        
        if (!drugName) continue
        
        // Собираем все названия препарата
        const allNames: string[] = [drugName]
        
        // Латинское название
        if (drug.latinName) {
          allNames.push(drug.latinName)
        }
        
        // Синонимы
        if (drug.synonyms && Array.isArray(drug.synonyms)) {
          const synonyms = drug.synonyms.filter(Boolean)
          allNames.push(...synonyms)
        }
        
        // Аналоги
        if (drug.analogs && Array.isArray(drug.analogs)) {
          const analogs = drug.analogs.filter(Boolean)
          allNames.push(...analogs)
          if (analogs.length > 0) {
            console.log(`🔍 Препарат "${drugName}" имеет аналоги:`, analogs)
          }
        }
        
        // Убираем дубликаты
        const uniqueNames = Array.from(new Set(allNames))
        
        // Добавляем в карту все названия препарата
        for (const name of uniqueNames) {
          newDrugsMap.set(name.toLowerCase(), {
            id: drugId,
            name: drugName,
            variants: uniqueNames
          })
        }
        
        // Добавляем в список только основное название
        drugNames.push(drugName)
      }
      
      // Создаем список препаратов (только основные названия)
      drugsList.value = drugNames
        .filter(name => name && name.length > 2)
        .sort((a, b) => b.length - a.length)
      
      // Сохраняем карту препаратов
      drugsMap.value = newDrugsMap
      
      console.log('✅ Список препаратов загружен:', drugsList.value.length, 'препаратов')
      console.log('✅ Карта препаратов создана:', drugsMap.value.size, 'записей')
      
      // Отладка карты препаратов (только первые 3 записи)
      console.log('🔍 Примеры записей в карте:')
      const sampleKeys = Array.from(drugsMap.value.keys()).slice(0, 3)
      for (const key of sampleKeys) {
        const drugInfo = drugsMap.value.get(key)
        console.log(`  "${key}" → ID: ${drugInfo?.id}, Name: ${drugInfo?.name}`)
      }
      
      // Сохраняем в кэш
      saveDrugsToCache(drugsList.value, drugsMap.value)
      
      console.log('✅ Список препаратов загружен')
      
    } else {
      console.warn('❌ Некорректный ответ API препаратов')
    }
  } catch (error) {
    console.warn('❌ Не удалось загрузить список препаратов:', error)
    console.log('Продолжаем без списка препаратов...')
  }
}

// Простая функция для парсинга препаратов в контенте
function parseDrugsInContent(html: string): string {
  if (!html) return html
  
  console.log('🔄 Начинаем парсинг препаратов в контенте...')
  console.log('🔍 Список препаратов:', drugsList.value.length, 'препаратов')
  console.log('🔍 Первые 10 препаратов:', drugsList.value.slice(0, 10))
  
  // Создаем временный DOM элемент для работы с HTML
  const tempDiv = document.createElement('div')
  tempDiv.innerHTML = html
  
  // Находим все таблицы
  const tables = tempDiv.querySelectorAll('table')
  console.log('🔍 Найдено таблиц:', tables.length)
  
  // Обрабатываем каждую таблицу
  tables.forEach((table, tableIndex) => {
    console.log(`🔄 Обрабатываем таблицу ${tableIndex + 1}`)
    
    // Находим все строки в tbody (исключаем заголовки)
    const rows = table.querySelectorAll('tbody tr')
    console.log(`🔍 Найдено строк в таблице ${tableIndex + 1}:`, rows.length)
    
    rows.forEach((row, rowIndex) => {
      // Получаем все ячейки в строке
      const cells = row.querySelectorAll('td')
      
      // Проверяем, что есть минимум 2 столбца
      if (cells.length >= 2) {
        // Обрабатываем только второй столбец (индекс 1)
        const secondCell = cells[1]
        console.log(`🔍 Обрабатываем строку ${rowIndex + 1}, столбец 2 в таблице ${tableIndex + 1}`)
        
        // Парсим препараты только во втором столбце
        const processedContent = parseDrugsInText(secondCell.innerHTML)
        secondCell.innerHTML = processedContent
      }
    })
  })
  
  // Также обрабатываем препараты в тексте вне таблиц
  const nonTableContent = tempDiv.cloneNode(true) as HTMLElement
  
  // Удаляем все таблицы из копии
  nonTableContent.querySelectorAll('table').forEach(table => table.remove())
  
  // Обрабатываем оставшийся контент
  const processedNonTableContent = parseDrugsInText(nonTableContent.innerHTML)
  nonTableContent.innerHTML = processedNonTableContent
  
  // Возвращаем обработанный HTML
  const result = tempDiv.innerHTML
  console.log('✅ Парсинг препаратов завершен')
  return result
}

// Функция для парсинга препаратов в тексте
function parseDrugsInText(text: string): string {
  if (!text) return text
  
  let result = text
  
  // Получаем все уникальные варианты названий из карты препаратов
  const allDrugVariants = new Set<string>()
  
  // Собираем все варианты названий из карты (включая аналоги и синонимы)
  drugsMap.value.forEach((drugInfo, key) => {
    // Добавляем все варианты названий для этого препарата
    if (drugInfo.variants) {
      drugInfo.variants.forEach(variant => {
        if (variant && variant.trim()) {
          allDrugVariants.add(variant)
        }
      })
    }
  })
  
  // Преобразуем в массив и сортируем по длине (длинные названия первыми)
  const sortedVariants = Array.from(allDrugVariants).sort((a, b) => b.length - a.length)
  
  console.log('🔍 Всего вариантов названий для поиска:', sortedVariants.length)
  console.log('🔍 Первые 10 вариантов:', sortedVariants.slice(0, 10))
      
  for (const variant of sortedVariants) {
    // Получаем информацию о препарате из карты
    const drugInfo = drugsMap.value.get(variant.toLowerCase())
    if (!drugInfo) continue
    
    // Создаем регулярное выражение для поиска варианта названия
    // Исключаем уже существующие ссылки
    const escapedVariant = variant.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
    const regex = new RegExp(`(?<!<a[^>]*>)${escapedVariant}(?![^<]*</a>)`, 'gi')
    
    // Проверяем, есть ли совпадения
    const matches = result.match(regex)
    if (matches && matches.length > 0) {
      console.log(`🔍 Найдено совпадений для "${variant}" (ID: ${drugInfo.id}): ${matches.length} шт`)
      
      // Заменяем найденные совпадения на ссылки
      result = result.replace(regex, (match) => {
        console.log(`🔄 Создаем ссылку для "${variant}" ID: ${drugInfo.id} для текста: "${match}"`)
        return `<a href="#" class="algocclink cursor-pointer" data-drug-id="${drugInfo.id}" data-drug-name="${drugInfo.name}">${match}</a>`
      })
    }
  }
  
  return result
}

// Функция для нормализации названий препаратов (убираем падежи и окончания)
function normalizeDrugName(name: string): string {
  if (!name) return ''
  
  let normalized = name.toLowerCase().trim()
  
  // Убираем общие окончания для разных падежей
  const endings = [
    // Родительный падеж (кого? чего?)
    'а', 'я', 'ы', 'и',
    // Дательный падеж (кому? чему?)
    'у', 'ю',
    // Винительный падеж (кого? что?)
    'а', 'я', 'у', 'ю',
    // Творительный падеж (кем? чем?)
    'ом', 'ем', 'ой', 'ей',
    // Предложный падеж (о ком? о чём?)
    'е', 'и'
  ]
  
  // Сортируем окончания по длине (длинные первыми)
  endings.sort((a, b) => b.length - a.length)
  
  // Убираем окончания
  for (const ending of endings) {
    if (normalized.endsWith(ending) && normalized.length > ending.length + 2) {
      normalized = normalized.slice(0, -ending.length)
      break // Убираем только одно окончание
    }
  }
  
  return normalized
}

// Функция для создания альтернативных вариантов названий препаратов
function createDrugVariants(name: string): string[] {
  if (!name) return []
  
  const variants = [name]
  const normalized = normalizeDrugName(name)
  
  // Добавляем нормализованный вариант только если он отличается
  if (normalized !== name.toLowerCase()) {
    variants.push(normalized)
  }
  
  // Добавляем варианты с падежами только для основных препаратов
  const lowerName = name.toLowerCase()
  
  // Для магния сульфат
  if (lowerName.includes('магния сульфат') && !lowerName.includes('sol')) {
    variants.push('магния сульфата', 'магния сульфатом')
  }
  
  // Для натрия хлорид
  if (lowerName.includes('натрия хлорид') && !lowerName.includes('sol')) {
    variants.push('натрия хлорида', 'натрия хлоридом')
  }
  
  // Для латинских названий добавляем русские варианты
  if (lowerName.includes('sol. natrii cloridi')) {
    variants.push('натрия хлорид', 'натрия хлорида')
  }
  
  if (lowerName.includes('sol magnesii sulfas')) {
    variants.push('магния сульфат', 'магния сульфата')
  }
  
  // Убираем дубликаты и возвращаем уникальные варианты
  return Array.from(new Set(variants))
}

// Функция для проверки совпадения названий препаратов
function matchesDrugName(text: string, drugName: string): boolean {
  if (!text || !drugName) return false
  
  // Ищем препарат в карте
  const drugInfo = drugsMap.value.get(drugName.toLowerCase())
  if (!drugInfo) return false
  
  const textLower = text.toLowerCase()
  
  // Проверяем все варианты названий препарата
  for (const variant of drugInfo.variants) {
    const variantLower = variant.toLowerCase()
    
    // Точное совпадение
    if (textLower === variantLower) {
      return true
    }
    
    // Содержит название препарата
    if (textLower.includes(variantLower) || variantLower.includes(textLower)) {
      return true
    }
  }
  
  return false
}

// Функция для поиска препарата в тексте
function findDrugInText(text: string, drugName: string): { found: boolean; startIndex: number; endIndex: number; matchedText: string; drugId: string } {
  if (!text || !drugName) return { found: false, startIndex: -1, endIndex: -1, matchedText: '', drugId: '' }
  
  // Ищем препарат в карте по названию
  const drugInfo = drugsMap.value.get(drugName.toLowerCase())
  if (!drugInfo) {
    return { found: false, startIndex: -1, endIndex: -1, matchedText: '', drugId: '' }
  }
  
  const textLower = text.toLowerCase()
  
  // Ищем по всем вариантам названий препарата
  for (const variant of drugInfo.variants) {
    const variantLower = variant.toLowerCase()
    const index = textLower.indexOf(variantLower)
    
    if (index !== -1) {
      return {
        found: true,
        startIndex: index,
        endIndex: index + variant.length,
        matchedText: text.substring(index, index + variant.length),
        drugId: drugInfo.id
      }
    }
  }
  
  return { found: false, startIndex: -1, endIndex: -1, matchedText: '', drugId: '' }
}


// Реактивный поиск локальных статусов при изменении алгоритма
watch(() => algo.value?.mkbCodes, () => {
  if (algo.value?.mkbCodes) {
    searchLocalStatuses()
  }
}, { immediate: true })

// Очищаем query при закрытии модалки препаратов
watch(drugsOpen, (isOpen) => {
  if (!isOpen) {
    // Небольшая задержка для корректной работы с модалкой
    setTimeout(() => {
      if (!drugsOpen.value) {
        drugsQuery.value = ''
        console.log('🔄 Очистили query при закрытии модалки')
      }
    }, 100)
  }
})


onBeforeUnmount(() => {
  const root = contentRef.value as any
  const handlers = root?.__mobileResizeHandlers as Array<() => void> | undefined
  if (handlers) {
    handlers.forEach((h) => window.removeEventListener('resize', h))
    root.__mobileResizeHandlers = []
  }
})
</script>


